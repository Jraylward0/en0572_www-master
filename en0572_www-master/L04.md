---
layout: default
title: Interrupt generation and handling - Timers
license: https://github.com/DavidKendall/interrupt/blob/master/LICENSE
---

# Introduction
This lab is concerned with interrupt handling for the LPC4088QSB
development board and the experiment base board. The goal is to
configure timers to generate interrupts periodically and
then to write a variety of interrupt handlers to control the behaviour
of the board. A good grasp of interrupts and interrupt handling is
essential for a proper understanding of operating systems.

# In the lab

1. Clone the `git` repository for this lab by executing the following command in the git bash shell:

    ``` shell-session
    $ git clone https://github.com/DavidKendall/interrupt
    ```
Build and run the program. Observe its behaviour, then study the code in
`main.c`. Notice that the program is more responsive to the use of the
joystick. Why is that so? What other advantages can you think of for the
interrupt-driven approach.

2. Your task now is to understand the main features of this program. You
need to understand:
    1. how the interrupt handler for TIMER0 is called when the interrupt occurs
    2. how TIMER0 is used to generate an interrupt at a given frequency

    Ask your lab tutor to explain these features to you.

3. Suppose that we'd like to be able to flash the LEDs at different
rates, e.g. LED1 and LED2 at 1&nbsp;Hz, but LED3 and LED4 at
2&nbsp;Hz. We could achieve this by using *two* different timers (the
LPC4088 provides four hardware timers in total): TIMER0 and TIMER1. To
demonstrate and reinforce your understanding of the interrupt handling and
timers, you should modify your program so that it uses TIMER1 to generate
an interrupt at 2&nbsp;Hz and handles this interrupt by flashing LED3 and
LED4, if required. Your program should continue to use TIMER0 to control
LED1 and LED2 at 1&nbsp;Hz. To achieve this you will need to
    * add code to `timer.c` to initialise TIMER1 and to implement the interrupt
handler `TIMER1_IRQHandler`. Update `timer.h` accordingly.
    * add code to `main.c` for the user-defined function to be used in the 
TIMER1 interrupt handler. Add a function call to `timer1Init` so that TIMER1
generates an interrupt periodically at 2&nbsp;Hz and calls your user-defined
function in the interrupt handler.

    Create a new branch in your `git` repository to save your changes, as follows:

    ``` shell-session
    $ git checkout -b X03
    ```
    Model your code for TIMER1 on the existing code for TIMER0. Build and
run your program. You should observe that LED3 and LED4 flash at twice the
rate of LED1 and LED2. When you are happy with your program, commit the changes
to your repository:

    ``` shell-session
    $ git status
    $ git add .
    $ git commit -m "My program for exercise 3"
    ```

4. The requirement to generate a periodic interrupt is so fundamental to
the implementation of operating systems that the designers of the Cortex-M 
series of microcontrollers have provided a hardware mechanism, known as
`SysTick`, that is even easier to use than the timers that we have seen so far.
Let's look at a program that uses `SysTick`. Checkout branch P04 from your repository, as follows:

    ``` shell-session
    $ git checkout P04
    ```

    Have a look at `timer.c` to see how the SysTick interrupt is initialised. The
most important code is shown below.

    ``` C
    /*
     * @brief Configure the SysTick timer to generate an interrupt 
     * @param tickHz - frequency at which to generate the interrupt
     * @param handler - the user-defined handler for the interrupt
     */
    void sysTickInit(uint32_t tickHz, void (*handler)()) {
	    SysTick->CTRL = 0;                              /* disable timer during configuration */
	    SysTick->LOAD = SystemCoreClock / tickHz - 1UL; /* fill the RELOAD register with a value for the rate */
	    SysTick->VAL = 0UL;                             /* any value written here resets the value counter to 0 */
	    sysTickUserDefinedHandler = handler;
	    SysTick->CTRL = 0x07;                           /* enable the counter, enable the interrupt, choose CPU clock */
    }
    ```
    
    Note that `SysTick` uses a 24-bit counter (unlike the 32-bit
    counters used by the regular TIMERs). We can't generate an
    interrupt at 1&nbsp;Hz directly using `SysTick`. Why not? What's
    the maximum period (roughly) that can be generated by `SysTick`,
    running on an LPC4088 clocked at 120&nbsp;MHz? Have a look at the
    function `sysTickHandler()` in `main.c`.  Notice how it's still
    possible to flash the LEDs at 1&nbsp;Hz, even though the `SysTick`
    interrupt fires at 1&nbsp;kHz.  Discuss these issues with your lab
    tutor.
    
5. We might wonder how we could manage to execute several different
activities, all at different rates, e.g. flash LED1, LED2, LED3 and
LED4 at 1&nbsp;Hz, 2&nbsp;Hz, 4&nbsp;Hz, and 8&nbsp;Hz,
respectively. We could just about manage to do this by using all four
hardware timers, TIMER0, .., TIMER3, but this approach is not
scalable. Why not? Another approach that generalises the approach used
in exercise 4, is to introduce *soft timers* that are managed by the
`SysTick` interrupt handler. Use `git` to checkout program `P05` to
see how this might work. In this program, we've introduced three soft
timers, defined in `timer.h`, and we update them using
`SysTick`. We've configured two soft timers to run functions that
flash LED1 and LED2, or LED3 and LED4. One function runs at 1&nbsp;Hz
and the other at 2&nbsp;Hz.  The other soft timer is used to execute a
function that checks for button presses. Once again, study the code
carefully, build it and run it. The behaviour that you observe should
be indistinguishable from the behaviour of your program for
exercise&nbsp;3.  But now we are using three soft timers controlled by
one hardware timer, instead of two hardware timers.  Discuss the
issues with your lab tutor.

6. Demonstrate your understanding of the code in the previous exercise
by modifying the program to use two additional soft timers, so that
now each of the LEDs can be controlled by its own individual soft
timer and you can solve the problem suggested earlier, namely to flash
LED1, LED2, LED3 and LED4 at 1&nbsp;Hz, 2&nbsp;Hz, 4&nbsp;Hz, and
8&nbsp;Hz, respectively. When you are happy with your program, 
create a new branch, X06, and commit your changes. Are you really happy
with it? Build it and run it. When you've got all of the LEDs flashing,
press and hold the joystick in any direction. What happens to the flashing
of the LEDs? Explain the behaviour that you observe.


7. If you want to get really fancy, rewrite
`buttonPressedAndReleased()` so that it no longer contains the busy
wait loop. You could try to do this by modifying the driver for the
GPIO pins to generate interrupts on the button presses and writing
handlers for these interrupts. However, there is a simpler solution.
Modify the existing *polling* solution to keep track of the previous
state of each button, i.e. whether it was pressed or released, and
compare this with the current state of the button. Your function
should return `true` when the previous state was *pressed* and the
current state is *released*, otherwise it should return `false` - no
need for any busy waiting! When you're happy with your program, build
and run it. Repeat the previous experiment of getting the LEDs
flashing and then holding the joystick pressed in some direction.  Now
what happens to the flashing of the LEDs? Explain the behaviour that
you observe.

If you've completed all of these exercises, then you should understand
how interrupts can be generated and handled, and you should have seen
that the approach using soft timers is the beginning of a very
primitive *scheduler* - a core component in any OS. More on this in
the coming weeks.






 